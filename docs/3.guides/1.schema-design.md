---
title: Schema Design
description: Best practices for designing maintainable Flume schemas
author: Flume Team
published: 2025-12-03
tags: [Guide, Schema, Best Practices]
---

# Schema Design

Best practices for designing clear, maintainable Flume schemas.

## Naming Conventions

### Processor Names

Use kebab-case with verb-noun patterns:

```go
// Good
pipz.Apply("validate-order", ...)
pipz.Apply("fetch-customer", ...)
pipz.Apply("send-notification", ...)

// Avoid
pipz.Apply("OrderValidation", ...)
pipz.Apply("customer", ...)
pipz.Apply("doStuff", ...)
```

### Predicate Names

Use is-/has-/can- prefixes:

```go
// Good
flume.Predicate[T]{Name: "is-premium", ...}
flume.Predicate[T]{Name: "has-discount-code", ...}
flume.Predicate[T]{Name: "can-ship-internationally", ...}

// Avoid
flume.Predicate[T]{Name: "premium", ...}
flume.Predicate[T]{Name: "check-discount", ...}
```

### Condition Names

Use get- prefix or descriptive nouns:

```go
// Good
flume.Condition[T]{Name: "get-order-type", ...}
flume.Condition[T]{Name: "payment-method", ...}
flume.Condition[T]{Name: "customer-tier", ...}
```

### Schema Names

Use descriptive kebab-case:

```go
factory.SetSchema("order-processing", ...)
factory.SetSchema("user-onboarding", ...)
factory.SetSchema("payment-v2", ...)
```

## Structure Guidelines

### Keep Depth Shallow

Deeply nested schemas are hard to read and debug:

```yaml
# Hard to follow (5+ levels)
type: sequence
children:
  - type: filter
    predicate: a
    then:
      type: switch
        condition: b
        routes:
          x:
            type: retry
            child:
              type: timeout
                child:
                  ref: processor
```

Break into logical sub-schemas:

```yaml
# Main schema
type: sequence
children:
  - ref: validate
  - ref: resilient-external-call  # Pre-composed
  - ref: finalize
```

```go
// Register composed processor
resilientCall := pipz.NewCircuitBreaker("resilient",
    pipz.NewTimeout("timeout", apiCall, 5*time.Second),
    3, 30*time.Second,
)
factory.Add(resilientCall)
```

### Group Related Operations

Use sequence to group related steps:

```yaml
type: sequence
name: payment-processing
children:
  - ref: validate-payment
  - ref: authorize-payment
  - ref: capture-payment
  - ref: record-transaction
```

### Name Complex Nodes

Add names to non-trivial nodes for debugging:

```yaml
type: concurrent
name: parallel-enrichment
children:
  - ref: fetch-customer
  - ref: fetch-inventory

type: filter
name: premium-check
predicate: is-premium
then:
  ref: premium-handler
```

## Version Management

### Semantic Versioning

Use semantic versioning for schemas:

```yaml
version: "1.0.0"  # Initial
version: "1.1.0"  # Added new route
version: "2.0.0"  # Breaking change to structure
```

### Version in Schema Name

For A/B testing or gradual rollouts:

```go
factory.SetSchema("checkout-v1", schemaV1)
factory.SetSchema("checkout-v2", schemaV2)

// Route traffic
schemaName := getSchemaForUser(user)
pipeline, _ := factory.Pipeline(schemaName)
```

## Error Handling Placement

### Wrap at Boundaries

Apply error handling at service boundaries:

```yaml
type: sequence
children:
  - ref: validate  # Internal - no wrap needed
  - type: circuit-breaker
    failure_threshold: 5
    child:
      type: retry
        attempts: 3
        child:
          ref: external-api  # External - wrap
  - ref: transform  # Internal - no wrap
```

### Don't Over-Protect

Avoid redundant error handling:

```yaml
# Overkill
type: retry
child:
  type: retry
    child:
      type: fallback
        children:
          - type: retry
              child:
                ref: processor
          - ref: fallback
```

### Match Retry to Operation

```yaml
# Quick operation - few retries, no backoff
type: retry
attempts: 2
child:
  ref: cache-lookup

# Slow external service - more retries with backoff
type: retry
attempts: 5
backoff: "500ms"
child:
  ref: payment-gateway
```

## Performance Considerations

### Minimize Cloning

`concurrent` and `race` nodes clone data. Avoid unnecessary parallelism:

```yaml
# Unnecessary clone
type: concurrent
children:
  - ref: quick-transform  # Could be sequential

# Justified parallelism
type: concurrent
children:
  - ref: slow-api-call
  - ref: another-slow-call
```

### Rate Limit at Entry Points

Place rate limiters early:

```yaml
type: sequence
children:
  - type: rate-limit
    requests_per_second: 100.0
    child:
      ref: validate  # Everything after is protected
  - ref: process
  - ref: external-call
```

### Use Timeouts Wisely

Set realistic timeouts:

```yaml
type: timeout
duration: "30s"  # Based on actual SLA
child:
  ref: external-service
```

## Schema Organization

### Single Responsibility

Each schema should do one thing well:

```go
// Separate concerns
factory.SetSchema("order-validation", validationSchema)
factory.SetSchema("order-payment", paymentSchema)
factory.SetSchema("order-fulfillment", fulfillmentSchema)
```

### Compose Larger Flows

Build complex flows from simple schemas:

```go
// High-level orchestration
factory.SetSchema("order-complete", Schema{
    Node: Node{
        Type: "sequence",
        Children: []Node{
            {Ref: "order-validation"},   // References another pipeline
            {Ref: "order-payment"},
            {Ref: "order-fulfillment"},
        },
    },
})
```

## Documentation Practices

### Use Descriptions

Add descriptions when registering:

```go
factory.AddPredicate(flume.Predicate[Order]{
    Name:        "high-value",
    Description: "Orders exceeding $1000 threshold for premium handling",
    Predicate:   isHighValue,
})

factory.AddCondition(flume.Condition[Order]{
    Name:        "fulfillment-type",
    Description: "Determines shipping vs. digital delivery",
    Values:      []string{"ship", "digital", "pickup"},
    Condition:   getFulfillmentType,
})
```

### Companion Documentation

Maintain schema documentation alongside files:

```
schemas/
  order-processing.yaml
  order-processing.md    # Documents the schema
```

### Schema Diagrams

For complex pipelines, create visual diagrams:

```
validate → [concurrent: enrich] → [filter: premium?] → [switch: payment] → complete
                                        ↓                    ↓
                                  premium-handler     credit|paypal|crypto
```

## Next Steps

- [Hot Reloading](2.hot-reloading.md) - Dynamic schema updates
- [Testing](4.testing.md) - Testing schema-driven pipelines
- [Schema Format Reference](../5.reference/2.schema-format.md) - Complete specification
