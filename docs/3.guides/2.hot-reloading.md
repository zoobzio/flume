---
title: Hot Reloading
description: Update pipeline behaviour at runtime without restarts
author: Flume Team
published: 2025-12-03
tags: [Guide, Hot Reload, Dynamic]
---

# Hot Reloading

Update pipeline definitions at runtime without service restarts.

## Overview

Flume's hot reloading enables:

- **Zero-downtime updates** - Swap pipelines while requests continue
- **A/B testing** - Switch between pipeline variants
- **Feature flags** - Enable/disable pipeline stages dynamically
- **Configuration-driven behaviour** - Operators modify pipelines without deploys

## Basic Usage

### Register Named Schemas

```go
factory := flume.New[Order]()

// Register components
factory.Add(processors...)
factory.AddPredicate(predicates...)

// Register named schema
schema := flume.Schema{
    Version: "1.0.0",
    Node: flume.Node{
        Type: "sequence",
        Children: []flume.Node{
            {Ref: "validate"},
            {Ref: "process"},
        },
    },
}

err := factory.SetSchema("order-pipeline", schema)
```

### Use the Pipeline

```go
pipeline, ok := factory.Pipeline("order-pipeline")
if !ok {
    return errors.New("pipeline not found")
}

result, err := pipeline.Process(ctx, order)
```

### Update at Runtime

```go
newSchema := flume.Schema{
    Version: "1.1.0",
    Node: flume.Node{
        Type: "sequence",
        Children: []flume.Node{
            {Ref: "validate"},
            {Ref: "enrich"},  // Added step
            {Ref: "process"},
        },
    },
}

err := factory.SetSchema("order-pipeline", newSchema)
// New requests immediately use updated pipeline
```

## How It Works

### Atomic Pointer Swap

```go
// Internally, pipelines are stored as atomic pointers
pipelines map[string]*atomic.Pointer[pipz.Chainable[T]]

// Update atomically swaps the pointer
ptr.Store(&newPipeline)

// Retrieval loads atomically
return *ptr.Load(), true
```

### Request Continuity

1. Request A starts with pipeline v1
2. Schema updates to v2
3. Request A completes with v1 (unaffected)
4. Request B starts with v2

No locks are held during processing - updates don't block requests.

## File-Based Reloading

### Watch for Changes

```go
func watchSchemaFile(ctx context.Context, factory *flume.Factory[Order], path string) {
    watcher, _ := fsnotify.NewWatcher()
    defer watcher.Close()

    watcher.Add(path)

    for {
        select {
        case <-ctx.Done():
            return
        case event := <-watcher.Events:
            if event.Op&fsnotify.Write == fsnotify.Write {
                reloadSchema(factory, path)
            }
        }
    }
}

func reloadSchema(factory *flume.Factory[Order], path string) {
    pipeline, err := factory.BuildFromFile(path)
    if err != nil {
        log.Printf("failed to reload schema: %v", err)
        return
    }

    // Read file to get schema for SetSchema
    data, _ := os.ReadFile(path)
    var schema flume.Schema
    yaml.Unmarshal(data, &schema)

    if err := factory.SetSchema("main", schema); err != nil {
        log.Printf("failed to set schema: %v", err)
    }
}
```

### Multi-Schema Directory

```go
func watchSchemaDir(ctx context.Context, factory *flume.Factory[Order], dir string) {
    watcher, _ := fsnotify.NewWatcher()
    watcher.Add(dir)

    for event := range watcher.Events {
        if event.Op&fsnotify.Write == 0 {
            continue
        }

        name := strings.TrimSuffix(filepath.Base(event.Name), filepath.Ext(event.Name))

        data, _ := os.ReadFile(event.Name)
        var schema flume.Schema
        if err := yaml.Unmarshal(data, &schema); err != nil {
            log.Printf("invalid schema %s: %v", name, err)
            continue
        }

        if err := factory.SetSchema(name, schema); err != nil {
            log.Printf("failed to update %s: %v", name, err)
        }
    }
}
```

## Remote Configuration

### HTTP Endpoint

```go
http.HandleFunc("/schemas/{name}", func(w http.ResponseWriter, r *http.Request) {
    name := r.PathValue("name")

    switch r.Method {
    case "GET":
        schema, ok := factory.GetSchema(name)
        if !ok {
            http.NotFound(w, r)
            return
        }
        json.NewEncoder(w).Encode(schema)

    case "PUT":
        var schema flume.Schema
        json.NewDecoder(r.Body).Decode(&schema)

        if err := factory.SetSchema(name, schema); err != nil {
            http.Error(w, err.Error(), 400)
            return
        }
        w.WriteHeader(204)

    case "DELETE":
        if !factory.RemoveSchema(name) {
            http.NotFound(w, r)
            return
        }
        w.WriteHeader(204)
    }
})
```

### Polling

```go
func pollSchemas(ctx context.Context, factory *flume.Factory[Order], url string) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            resp, err := http.Get(url)
            if err != nil {
                continue
            }

            var schemas map[string]flume.Schema
            json.NewDecoder(resp.Body).Decode(&schemas)
            resp.Body.Close()

            for name, schema := range schemas {
                existing, ok := factory.GetSchema(name)
                if ok && existing.Version == schema.Version {
                    continue // No change
                }
                factory.SetSchema(name, schema)
            }
        }
    }
}
```

## Version Tracking

### Compare Versions

```go
existing, ok := factory.GetSchema("pipeline")
if ok && existing.Version == newSchema.Version {
    return // Already up to date
}

err := factory.SetSchema("pipeline", newSchema)
```

### Observability

Flume emits events on schema changes:

```go
import "github.com/zoobzio/capitan"

capitan.Handle(flume.SchemaUpdated, func(ctx context.Context, fields []capitan.Field) {
    var name, oldVersion, newVersion string
    for _, f := range fields {
        switch f.Key {
        case "name":
            name = f.String()
        case "old_version":
            oldVersion = f.String()
        case "new_version":
            newVersion = f.String()
        }
    }
    log.Printf("schema %s updated: %s -> %s", name, oldVersion, newVersion)
})
```

## Graceful Updates

### Validation First

Always validate before applying:

```go
if err := factory.ValidateSchema(newSchema); err != nil {
    return fmt.Errorf("invalid schema: %w", err)
}

// Schema is valid, safe to apply
factory.SetSchema(name, newSchema)
```

### Rollback Pattern

```go
func updateWithRollback(factory *flume.Factory[Order], name string, newSchema flume.Schema) error {
    // Save current
    oldSchema, hadOld := factory.GetSchema(name)

    // Apply new
    if err := factory.SetSchema(name, newSchema); err != nil {
        return err
    }

    // Test with canary request
    pipeline, _ := factory.Pipeline(name)
    _, err := pipeline.Process(context.Background(), canaryOrder)

    if err != nil && hadOld {
        // Rollback
        factory.SetSchema(name, oldSchema)
        return fmt.Errorf("canary failed, rolled back: %w", err)
    }

    return nil
}
```

## Best Practices

### 1. Use Semantic Versioning

```yaml
version: "1.2.3"  # MAJOR.MINOR.PATCH
```

### 2. Log All Changes

```go
log.Printf("schema %s updated to version %s", name, schema.Version)
```

### 3. Validate Component Dependencies

Before removing a processor, check if schemas reference it:

```go
for _, schemaName := range factory.ListSchemas() {
    schema, _ := factory.GetSchema(schemaName)
    if schemaReferencesProcessor(schema, "old-processor") {
        return fmt.Errorf("cannot remove: schema %s uses it", schemaName)
    }
}
```

### 4. Consider Circuit Breakers

Protect against bad schema updates:

```go
type GuardedFactory[T pipz.Cloner[T]] struct {
    factory       *flume.Factory[T]
    updateBreaker *circuitbreaker.CircuitBreaker
}

func (g *GuardedFactory[T]) SetSchema(name string, schema flume.Schema) error {
    return g.updateBreaker.Execute(func() error {
        return g.factory.SetSchema(name, schema)
    })
}
```

## Next Steps

- [Testing](4.testing.md) - Test hot reload scenarios
- [Observability](5.observability.md) - Monitor schema changes
- [Events Reference](../5.reference/4.events.md) - All schema events
