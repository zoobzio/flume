---
title: Connector Types
description: Detailed reference for all Flume connector types
author: Flume Team
published: 2025-12-03
tags: [Reference, Connectors, Types]
---

# Connector Types

Detailed reference for all Flume connector types and their behaviour.

## Flow Control

### sequence

Processes data through multiple steps in order.

**Schema:**
```yaml
type: sequence
children:
  - ref: step1
  - ref: step2
  - ref: step3
```

**Behaviour:**
1. Process step1 with input data
2. Pass step1 output to step2
3. Pass step2 output to step3
4. Return step3 output

**Error Handling:** Stops on first error, returns that error.

**Use Cases:**
- Multi-stage processing
- Pipeline composition
- Sequential transformations

---

### concurrent

Executes multiple steps in parallel.

**Schema:**
```yaml
type: concurrent
children:
  - ref: task1
  - ref: task2
  - ref: task3
```

**Behaviour:**
1. Clone input data for each child
2. Execute all children concurrently
3. Wait for all to complete
4. Merge results

**Error Handling:** Collects all errors, returns first error encountered.

**Requirements:** Type `T` must implement `pipz.Cloner[T]`.

**Use Cases:**
- Parallel enrichment from multiple sources
- Independent validations
- Concurrent API calls

---

### race

Returns first successful result.

**Schema:**
```yaml
type: race
children:
  - ref: fast-path
  - ref: slow-path
```

**Behaviour:**
1. Clone input data for each child
2. Execute all children concurrently
3. Return first successful result
4. Cancel other executions

**Error Handling:** Returns error only if all children fail.

**Requirements:** Type `T` must implement `pipz.Cloner[T]`.

**Use Cases:**
- Redundant data sources
- Fastest-wins scenarios
- Speculative execution

---

## Error Handling

### fallback

Provides backup processing on failure.

**Schema:**
```yaml
type: fallback
children:
  - ref: primary
  - ref: backup
```

**Behaviour:**
1. Execute primary with input
2. If primary succeeds, return result
3. If primary fails, execute backup
4. Return backup result or error

**Requirements:** Exactly 2 children.

**Use Cases:**
- Service redundancy
- Graceful degradation
- Default value provision

---

### retry

Retries on transient failures.

**Schema:**
```yaml
type: retry
attempts: 3
child:
  ref: operation
```

With backoff:
```yaml
type: retry
attempts: 5
backoff: "100ms"
child:
  ref: operation
```

**Behaviour without backoff:**
1. Execute child
2. If error, retry up to `attempts` times
3. Return success or final error

**Behaviour with backoff:**
1. Execute child
2. If error, wait `backoff` duration
3. Retry with doubled wait time (exponential)
4. Continue until success or `attempts` exhausted

**Defaults:**
- `attempts`: 3
- `backoff`: none (immediate retry)

**Use Cases:**
- Network timeouts
- Rate limit handling
- Transient service failures

---

### timeout

Enforces execution time limit.

**Schema:**
```yaml
type: timeout
duration: "5s"
child:
  ref: operation
```

**Behaviour:**
1. Start child execution with deadline context
2. If completes before deadline, return result
3. If deadline exceeded, cancel and return error

**Default:** 30 seconds

**Error:** Returns `context.DeadlineExceeded`

**Use Cases:**
- External API calls
- Long-running computations
- User-facing requests

---

### circuit-breaker

Prevents repeated calls to failing services.

**Schema:**
```yaml
type: circuit-breaker
failure_threshold: 5
recovery_timeout: "30s"
child:
  ref: service
```

**States:**

| State | Behaviour |
|-------|-----------|
| Closed | Normal operation, count failures |
| Open | Fail immediately, don't call child |
| Half-Open | Allow one test request |

**Behaviour:**
1. **Closed:** Execute child, count failures
2. After `failure_threshold` failures, open circuit
3. **Open:** Return error immediately
4. After `recovery_timeout`, enter half-open
5. **Half-Open:** Execute one test request
6. If test succeeds, close circuit
7. If test fails, reopen circuit

**Defaults:**
- `failure_threshold`: 5
- `recovery_timeout`: 60s

**Use Cases:**
- External service protection
- Cascade failure prevention
- Allowing service recovery

---

### rate-limit

Controls request throughput.

**Schema:**
```yaml
type: rate-limit
requests_per_second: 100.0
burst_size: 10
child:
  ref: operation
```

**Behaviour:**
1. Wait for token from bucket
2. Execute child
3. Return result

Uses token bucket algorithm:
- Tokens added at `requests_per_second` rate
- Up to `burst_size` tokens can accumulate
- Request waits if no tokens available

**Defaults:**
- `requests_per_second`: 10.0
- `burst_size`: 1

**Use Cases:**
- API rate limit compliance
- Resource protection
- Fair usage enforcement

---

## Routing

### filter

Conditional execution based on boolean predicate.

**Schema:**
```yaml
type: filter
predicate: is-valid
then:
  ref: process
else:
  ref: handle-invalid  # Optional
```

**Behaviour with else:**
1. Evaluate predicate
2. If true, execute `then` branch
3. If false, execute `else` branch
4. Return result

**Behaviour without else:**
1. Evaluate predicate
2. If true, execute `then` branch
3. If false, pass data through unchanged

**Requirements:** Predicate must be registered with factory.

**Use Cases:**
- Conditional processing
- Feature flags
- Validation gates

---

### switch

Multi-way routing based on condition value.

**Schema:**
```yaml
type: switch
condition: category
routes:
  electronics:
    ref: handle-electronics
  clothing:
    ref: handle-clothing
  food:
    ref: handle-food
default:
  ref: handle-other
```

**Behaviour:**
1. Evaluate condition function
2. Match return value to route key
3. Execute matched route
4. If no match and default exists, execute default
5. If no match and no default, pass through unchanged

**Default Route:** The condition function should return `"default"` for default routing.

**Requirements:** Condition must be registered with factory.

**Use Cases:**
- Multi-tenant routing
- Category handling
- Status-based processing

---

## Streaming

### stream

Sends data to a registered channel.

**Schema (terminal):**
```yaml
stream: output-channel
```

**Schema (with continuation):**
```yaml
stream: audit-channel
child:
  ref: continue-processing
```

**Behaviour (terminal):**
1. Send data to channel
2. Return data (unchanged)

**Behaviour (with child):**
1. Send data to channel
2. Execute child
3. Return child result

**Channel Behaviour:**
- Blocks if channel is full
- Non-blocking requires buffered channel

**Requirements:** Channel must be registered with factory.

**Use Cases:**
- Stream processing integration
- Async event publishing
- Audit logging
- Fan-out patterns

---

## Comparison Table

| Type | Purpose | Error Behaviour | Cloning |
|------|---------|-----------------|---------|
| sequence | Chain steps | Stop on error | No |
| concurrent | Parallel execution | Return first error | Yes |
| race | First success | Error if all fail | Yes |
| fallback | Backup processing | Try backup | No |
| retry | Transient failures | Retry n times | No |
| timeout | Time limit | Cancel on timeout | No |
| circuit-breaker | Failure protection | Fail fast when open | No |
| rate-limit | Throughput control | Wait for token | No |
| filter | Conditional routing | From branch | No |
| switch | Multi-way routing | From route | No |
| stream | Channel output | From send | No |

## Next Steps

- [Schema Format](2.schema-format.md) - YAML/JSON syntax
- [Events](4.events.md) - Observability signals
- [Cookbook](../4.cookbook/1.recipes.md) - Pattern examples
