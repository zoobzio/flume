---
title: API Reference
description: Complete reference for Flume's public API
author: Flume Team
published: 2025-12-03
tags: [Reference, API, Documentation]
---

# API Reference

Complete reference for Flume's public API.

## Factory

### New

Creates a new factory for type `T`.

```go
func New[T pipz.Cloner[T]]() *Factory[T]
```

**Type Constraint:** `T` must implement `pipz.Cloner[T]`.

**Example:**
```go
factory := flume.New[Order]()
```

---

## Processor Registration

### Add

Registers one or more processors using their intrinsic names.

```go
func (f *Factory[T]) Add(processors ...pipz.Chainable[T])
```

**Parameters:**
- `processors` - Variadic list of pipz chainables

**Example:**
```go
factory.Add(
    pipz.Apply("validate", validateOrder),
    pipz.Transform("enrich", enrichOrder),
)
```

---

### AddWithMeta

Registers processors with metadata for introspection.

```go
func (f *Factory[T]) AddWithMeta(processors ...ProcessorMeta[T])
```

**Parameters:**
- `processors` - Variadic list of ProcessorMeta structs

**Example:**
```go
factory.AddWithMeta(flume.ProcessorMeta[Order]{
    Processor:   pipz.Apply("validate", validateOrder),
    Description: "Validates order fields",
    Tags:        []string{"validation", "required"},
})
```

---

### Remove

Removes processors by name.

```go
func (f *Factory[T]) Remove(names ...pipz.Name) int
```

**Parameters:**
- `names` - Variadic list of processor names

**Returns:** Number of processors removed

**Example:**
```go
removed := factory.Remove("old-processor", "deprecated")
```

---

### HasProcessor

Checks if a processor is registered.

```go
func (f *Factory[T]) HasProcessor(name pipz.Name) bool
```

---

### ListProcessors

Returns all registered processor names.

```go
func (f *Factory[T]) ListProcessors() []pipz.Name
```

---

## Predicate Registration

### AddPredicate

Registers predicates for filter conditions.

```go
func (f *Factory[T]) AddPredicate(predicates ...Predicate[T])
```

**Example:**
```go
factory.AddPredicate(flume.Predicate[Order]{
    Name:        "is-premium",
    Description: "Customer has premium tier",
    Predicate: func(ctx context.Context, o Order) bool {
        return o.CustomerTier == "premium"
    },
})
```

---

### RemovePredicate

Removes predicates by name.

```go
func (f *Factory[T]) RemovePredicate(names ...pipz.Name) int
```

---

### HasPredicate

Checks if a predicate is registered.

```go
func (f *Factory[T]) HasPredicate(name pipz.Name) bool
```

---

### ListPredicates

Returns all registered predicate names.

```go
func (f *Factory[T]) ListPredicates() []pipz.Name
```

---

## Condition Registration

### AddCondition

Registers conditions for switch routing.

```go
func (f *Factory[T]) AddCondition(conditions ...Condition[T])
```

**Example:**
```go
factory.AddCondition(flume.Condition[Order]{
    Name:        "order-status",
    Description: "Returns the order status",
    Values:      []string{"pending", "approved", "rejected"},
    Condition: func(ctx context.Context, o Order) string {
        return o.Status
    },
})
```

---

### RemoveCondition

Removes conditions by name.

```go
func (f *Factory[T]) RemoveCondition(names ...pipz.Name) int
```

---

### HasCondition

Checks if a condition is registered.

```go
func (f *Factory[T]) HasCondition(name pipz.Name) bool
```

---

### ListConditions

Returns all registered condition names.

```go
func (f *Factory[T]) ListConditions() []pipz.Name
```

---

## Channel Registration

### AddChannel

Registers a channel for stream nodes.

```go
func (f *Factory[T]) AddChannel(name string, channel chan<- T)
```

**Example:**
```go
ch := make(chan Order, 100)
factory.AddChannel("orders", ch)
```

---

### GetChannel

Retrieves a registered channel.

```go
func (f *Factory[T]) GetChannel(name string) (chan<- T, bool)
```

---

### HasChannel

Checks if a channel is registered.

```go
func (f *Factory[T]) HasChannel(name string) bool
```

---

### ListChannels

Returns all registered channel names.

```go
func (f *Factory[T]) ListChannels() []string
```

---

### RemoveChannel

Removes a channel from the factory.

```go
func (f *Factory[T]) RemoveChannel(name string) bool
```

---

## Building Pipelines

### Build

Builds a pipeline from a Schema struct.

```go
func (f *Factory[T]) Build(schema Schema) (pipz.Chainable[T], error)
```

**Example:**
```go
schema := flume.Schema{
    Version: "1.0.0",
    Node: flume.Node{
        Type: "sequence",
        Children: []flume.Node{
            {Ref: "validate"},
            {Ref: "process"},
        },
    },
}
pipeline, err := factory.Build(schema)
```

---

### BuildFromYAML

Builds a pipeline from a YAML string.

```go
func (f *Factory[T]) BuildFromYAML(yamlStr string) (pipz.Chainable[T], error)
```

**Example:**
```go
schema := `
type: sequence
children:
  - ref: validate
  - ref: process
`
pipeline, err := factory.BuildFromYAML(schema)
```

---

### BuildFromJSON

Builds a pipeline from a JSON string.

```go
func (f *Factory[T]) BuildFromJSON(jsonStr string) (pipz.Chainable[T], error)
```

---

### BuildFromFile

Builds a pipeline from a file (YAML or JSON).

```go
func (f *Factory[T]) BuildFromFile(path string) (pipz.Chainable[T], error)
```

**Supported Extensions:** `.yaml`, `.yml`, `.json`

---

## Schema Management

### SetSchema

Adds or updates a named schema.

```go
func (f *Factory[T]) SetSchema(name string, schema Schema) error
```

Validates the schema, builds the pipeline, and stores both. If the schema exists, atomically updates it.

**Example:**
```go
err := factory.SetSchema("order-pipeline", schema)
```

---

### GetSchema

Retrieves a schema by name.

```go
func (f *Factory[T]) GetSchema(name string) (Schema, bool)
```

---

### RemoveSchema

Removes a named schema.

```go
func (f *Factory[T]) RemoveSchema(name string) bool
```

**Returns:** `true` if removed, `false` if not found

---

### ListSchemas

Returns all registered schema names.

```go
func (f *Factory[T]) ListSchemas() []string
```

---

### Pipeline

Returns the current pipeline for a named schema.

```go
func (f *Factory[T]) Pipeline(name string) (pipz.Chainable[T], bool)
```

Thread-safe with atomic access for hot-reload support.

**Example:**
```go
pipeline, ok := factory.Pipeline("order-pipeline")
if !ok {
    return errors.New("pipeline not found")
}
result, err := pipeline.Process(ctx, order)
```

---

## Validation

### ValidateSchema

Validates a schema without building it.

```go
func (f *Factory[T]) ValidateSchema(schema Schema) error
```

**Returns:** `nil` if valid, `ValidationErrors` otherwise

**Example:**
```go
if err := factory.ValidateSchema(schema); err != nil {
    fmt.Println(err)
    // 3 validation errors:
    //   1. root.children[0]: processor 'missing' not found
    //   ...
}
```

---

## Types

### Schema

```go
type Schema struct {
    Version string `json:"version,omitempty" yaml:"version,omitempty"`
    Node    `yaml:",inline"`
}
```

### Node

```go
type Node struct {
    Ref               string          // Processor reference
    Type              string          // Connector type
    Name              string          // Optional name override
    Children          []Node          // For sequence, concurrent, etc.
    Child             *Node           // For retry, timeout, etc.
    Predicate         string          // For filter
    Then              *Node           // For filter
    Else              *Node           // For filter
    Condition         string          // For switch
    Routes            map[string]Node // For switch
    Default           *Node           // For switch
    Attempts          int             // For retry
    Backoff           string          // For retry
    Duration          string          // For timeout
    FailureThreshold  int             // For circuit-breaker
    RecoveryTimeout   string          // For circuit-breaker
    RequestsPerSecond float64         // For rate-limit
    BurstSize         int             // For rate-limit
    Stream            string          // For stream nodes
}
```

### Predicate

```go
type Predicate[T any] struct {
    Name        pipz.Name
    Description string
    Predicate   func(context.Context, T) bool
}
```

### Condition

```go
type Condition[T any] struct {
    Name        pipz.Name
    Description string
    Values      []string  // Possible return values
    Condition   func(context.Context, T) string
}
```

### ProcessorMeta

```go
type ProcessorMeta[T any] struct {
    Processor   pipz.Chainable[T]
    Description string
    Tags        []string
}
```

### ValidationError

```go
type ValidationError struct {
    Path    []string  // Path to error in schema
    Message string
}

func (e ValidationError) Error() string
```

### ValidationErrors

```go
type ValidationErrors []ValidationError

func (e ValidationErrors) Error() string
```

---

## Constants

### Default Values

```go
const (
    DefaultRetryAttempts           = 3
    DefaultTimeoutDuration         = 30 * time.Second
    DefaultCircuitBreakerThreshold = 5
    DefaultRecoveryTimeout         = 60 * time.Second
    DefaultRequestsPerSecond       = 10.0
    DefaultBurstSize               = 1
)
```

## Next Steps

- [Schema Format](2.schema-format.md) - YAML/JSON specification
- [Connector Types](3.connector-types.md) - All connector options
- [Events](4.events.md) - Observability signals
