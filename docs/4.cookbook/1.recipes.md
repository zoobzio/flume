---
title: Common Recipes
description: Ready-to-use pipeline patterns for common scenarios
author: Flume Team
published: 2025-12-03
tags: [Cookbook, Recipes, Patterns]
---

# Common Recipes

Ready-to-use pipeline patterns for common scenarios.

## Validation Pipeline

Validate data through multiple stages:

```yaml
type: sequence
name: multi-stage-validation
children:
  - ref: validate-format
  - ref: validate-business-rules
  - ref: validate-permissions
  - ref: sanitize-input
```

```go
factory.Add(
    pipz.Apply("validate-format", func(ctx context.Context, d Data) (Data, error) {
        if d.Email == "" {
            return d, errors.New("email required")
        }
        if !isValidEmail(d.Email) {
            return d, errors.New("invalid email format")
        }
        return d, nil
    }),
    // ... other validators
)
```

## ETL Pipeline

Extract, transform, load pattern:

```yaml
type: sequence
name: etl-pipeline
children:
  # Extract
  - type: concurrent
    name: extract
    children:
      - ref: fetch-from-api
      - ref: fetch-from-db
      - ref: fetch-from-cache

  # Transform
  - ref: merge-data
  - ref: normalize
  - ref: enrich

  # Load
  - type: concurrent
    name: load
    children:
      - ref: write-to-warehouse
      - ref: update-cache
      - ref: publish-event
```

## Resilient API Call

Call an external API with full resilience:

```yaml
type: circuit-breaker
name: resilient-api
failure_threshold: 5
recovery_timeout: "30s"
child:
  type: timeout
  duration: "10s"
  child:
    type: retry
    attempts: 3
    backoff: "500ms"
    child:
      type: rate-limit
      requests_per_second: 100.0
      burst_size: 10
      child:
        ref: call-external-api
```

## Conditional Processing

Route based on data attributes:

```yaml
type: filter
name: premium-check
predicate: is-premium-customer
then:
  type: sequence
  children:
    - ref: apply-discount
    - ref: priority-queue
    - ref: premium-support
else:
  type: sequence
  children:
    - ref: standard-queue
    - ref: basic-support
```

## Multi-Tenant Routing

Route to different handlers per tenant:

```yaml
type: switch
name: tenant-router
condition: get-tenant-id
routes:
  tenant-a:
    type: sequence
    children:
      - ref: tenant-a-config
      - ref: process
  tenant-b:
    type: sequence
    children:
      - ref: tenant-b-config
      - ref: process
  enterprise:
    type: sequence
    children:
      - ref: enterprise-config
      - ref: premium-process
default:
  ref: default-process
```

```go
factory.AddCondition(flume.Condition[Request]{
    Name: "get-tenant-id",
    Condition: func(ctx context.Context, r Request) string {
        return r.TenantID
    },
})
```

## Fan-Out Pattern

Process data and send to multiple destinations:

```yaml
type: sequence
children:
  - ref: validate
  - ref: process
  - type: concurrent
    name: fan-out
    children:
      - ref: send-to-queue-a
      - ref: send-to-queue-b
      - ref: update-database
      - ref: send-notification
```

## Enrichment Pipeline

Enrich data from multiple sources:

```yaml
type: sequence
children:
  - ref: validate-input
  - type: concurrent
    name: parallel-enrichment
    children:
      - type: fallback
        children:
          - ref: get-user-from-cache
          - ref: get-user-from-db
      - ref: get-product-details
      - ref: calculate-pricing
  - ref: merge-enrichment
  - ref: finalize
```

## A/B Testing

Route traffic between variants:

```yaml
type: switch
name: ab-test-checkout
condition: get-experiment-variant
routes:
  control:
    ref: checkout-v1
  variant-a:
    ref: checkout-v2
  variant-b:
    ref: checkout-v3
default:
  ref: checkout-v1
```

```go
factory.AddCondition(flume.Condition[Request]{
    Name: "get-experiment-variant",
    Condition: func(ctx context.Context, r Request) string {
        // Hash user ID to consistent variant
        hash := fnv.New32a()
        hash.Write([]byte(r.UserID))
        bucket := hash.Sum32() % 100

        switch {
        case bucket < 50:
            return "control"
        case bucket < 75:
            return "variant-a"
        default:
            return "variant-b"
        }
    },
})
```

## Feature Flag

Enable/disable features dynamically:

```yaml
type: filter
name: feature-new-ui
predicate: feature-enabled-new-ui
then:
  ref: new-ui-handler
else:
  ref: legacy-ui-handler
```

```go
factory.AddPredicate(flume.Predicate[Request]{
    Name: "feature-enabled-new-ui",
    Predicate: func(ctx context.Context, r Request) bool {
        return featureFlags.IsEnabled("new-ui", r.UserID)
    },
})
```

## Batch Processing

Process items in a batch:

```yaml
type: sequence
name: batch-processor
children:
  - ref: validate-batch
  - type: concurrent
    children:
      - ref: process-subset-1
      - ref: process-subset-2
      - ref: process-subset-3
  - ref: aggregate-results
  - ref: store-batch-result
```

## Webhook Handler

Handle incoming webhooks with verification:

```yaml
type: sequence
name: webhook-handler
children:
  - ref: verify-signature
  - ref: parse-payload
  - type: switch
    condition: webhook-type
    routes:
      payment.completed:
        ref: handle-payment-complete
      subscription.created:
        ref: handle-subscription-created
      subscription.cancelled:
        ref: handle-subscription-cancelled
    default:
      ref: log-unknown-event
  - ref: send-acknowledgment
```

## Caching Pattern

Try cache first, fall back to source:

```yaml
type: fallback
name: cached-fetch
children:
  - ref: get-from-cache
  - type: sequence
    children:
      - ref: fetch-from-source
      - ref: update-cache
```

## Dead Letter Queue

Handle failures with DLQ:

```yaml
type: fallback
name: process-with-dlq
children:
  - type: retry
    attempts: 3
    backoff: "1s"
    child:
      ref: process-message
  - ref: send-to-dlq
```

## Rate-Limited Batch

Process batch with rate limiting:

```yaml
type: rate-limit
name: rate-limited-batch
requests_per_second: 10.0
burst_size: 1
child:
  type: sequence
  children:
    - ref: fetch-item
    - ref: process-item
    - ref: store-result
```

## Next Steps

- [Channel Integration](2.channel-integration.md) - Streaming patterns
- [Connector Types Reference](../5.reference/3.connector-types.md) - All options
- [Schema Design](../3.guides/1.schema-design.md) - Best practices
