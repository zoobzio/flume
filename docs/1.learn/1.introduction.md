---
title: Introduction to Flume
description: Learn what Flume is, the problems it solves, and when to use it
author: Flume Team
published: 2025-12-03
tags: [Introduction, Overview, Getting Started]
---

# Introduction to Flume

Flume is a dynamic pipeline factory for [pipz](https://github.com/zoobzio/pipz) that enables schema-driven pipeline construction with hot-reloading capabilities.

## The Problem

Building data processing pipelines in Go typically requires:

1. **Compile-time definitions** - Pipeline structure is fixed at build time
2. **Code changes for modifications** - Any pipeline change requires recompilation
3. **Scattered logic** - Pipeline composition logic spread across multiple files
4. **Limited reusability** - Hard to share common patterns across pipelines

```go
// Traditional approach: hardcoded pipeline structure
pipeline := pipz.NewSequence("process",
    validateProcessor,
    pipz.NewFilter("premium-check", isPremium, premiumHandler),
    pipz.NewRetry("payment", paymentProcessor, 3),
)
```

## The Solution

Flume separates pipeline **components** from pipeline **structure**:

```go
// Register reusable components once
factory := flume.New[Order]()
factory.Add(validateProcessor, premiumHandler, paymentProcessor)
factory.AddPredicate(flume.Predicate[Order]{Name: "is-premium", Predicate: isPremium})

// Define structure in configuration
schema := `
type: sequence
children:
  - ref: validate
  - type: filter
    predicate: is-premium
    then:
      ref: premium-handler
  - type: retry
    attempts: 3
    child:
      ref: payment
`

// Build and use
pipeline, _ := factory.BuildFromYAML(schema)
```

Now you can:
- **Update pipelines without recompilation** - Change the schema, reload
- **Define structure declaratively** - YAML/JSON schemas are self-documenting
- **Reuse components** - Register once, use in multiple schemas
- **Hot-reload in production** - Swap pipeline behaviour at runtime

## When to Use Flume

Flume is ideal when you need:

| Use Case | Why Flume Helps |
|----------|----------------|
| **Configurable pipelines** | Define structure in config files, not code |
| **A/B testing** | Switch between pipeline variants without deploys |
| **Multi-tenant systems** | Different processing per tenant via schemas |
| **Feature flags** | Enable/disable pipeline stages dynamically |
| **Admin interfaces** | Let operators modify pipelines without code |

## When Not to Use Flume

Flume adds indirection. Consider alternatives when:

- Pipeline structure never changes
- You need maximum performance (direct pipz is slightly faster)
- Schema complexity outweighs flexibility benefits
- You have fewer than 5 processors

## Design Philosophy

### Configuration Over Code

Pipeline structure belongs in configuration. Business logic belongs in code.

```yaml
# Configuration: structure
type: sequence
children:
  - ref: validate
  - ref: process
```

```go
// Code: behaviour
factory.Add(pipz.Apply("validate", func(ctx context.Context, o Order) (Order, error) {
    if o.Total <= 0 {
        return o, errors.New("invalid total")
    }
    return o, nil
}))
```

### Type Safety

Flume preserves Go's type safety through generics:

```go
factory := flume.New[Order]()      // Type-safe factory
factory.Add(orderProcessor)         // Only accepts Order processors
pipeline, _ := factory.Build(schema)
result, _ := pipeline.Process(ctx, order) // Returns Order
```

### Zero Magic

- Processors name themselves via `pipz.Name`
- Schemas are plain YAML/JSON
- Validation errors include full paths
- No reflection at runtime

### Composable

Build complex pipelines from simple, tested components:

```yaml
type: sequence
children:
  - ref: validate           # Simple processor
  - type: concurrent        # Parallel execution
    children:
      - ref: enrich
      - ref: score
  - type: filter            # Conditional
    predicate: high-value
    then:
      type: retry           # Error handling
      attempts: 3
      child:
        ref: premium-process
```

## Comparison to Alternatives

| Feature | Raw pipz | Flume | Workflow Engines |
|---------|----------|-------|------------------|
| Type safety | Full | Full | Partial |
| Hot reload | No | Yes | Yes |
| Schema validation | N/A | Yes | Yes |
| Setup complexity | None | Low | High |
| External dependencies | None | None | Often required |

### Performance

Once built, Flume pipelines execute with zero overhead compared to raw pipz - the built pipeline *is* a pipz pipeline. The only cost is at build time:

| Operation | Time | Allocations |
|-----------|------|-------------|
| Pipeline execution (single processor) | ~84 ns | 0 |
| Pipeline execution (3-step sequence) | ~459 ns | 2 |
| Pipeline execution (complex nested) | ~625 ns | 3 |
| Schema build (single ref) | ~1.3 µs | 6 |
| Schema build (10-step sequence) | ~6.7 µs | 62 |

Build once, execute many times - the build cost amortises to nothing.

## Next Steps

- [Core Concepts](2.core-concepts.md) - Understand factories, schemas, and components
- [Quickstart](../2.tutorials/1.quickstart.md) - Build your first pipeline
- [Schema Format](../5.reference/2.schema-format.md) - Complete schema specification
