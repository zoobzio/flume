name: Version Preview

on:
  pull_request:
    branches: [ main, master ]
    types: [ opened, synchronize, reopened ]

permissions:
  contents: read
  pull-requests: write

jobs:
  version-preview:
    name: Preview Next Version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current version
        id: current
        run: |
          # Get the latest tag
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Analyze commits
        id: analyze
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline --pretty=format:"%s")
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --oneline --pretty=format:"%s")
          fi

          echo "Commits since last tag:"
          echo "$COMMITS"

          # Determine version bump type
          BUMP="patch"
          BREAKING=false
          FEATURE=false

          while IFS= read -r commit; do
            if [[ "$commit" =~ ^feat!: ]] || [[ "$commit" =~ BREAKING ]]; then
              BREAKING=true
            elif [[ "$commit" =~ ^feat: ]] || [[ "$commit" =~ ^feat\( ]]; then
              FEATURE=true
            fi
          done <<< "$COMMITS"

          if [ "$BREAKING" = true ]; then
            BUMP="major"
          elif [ "$FEATURE" = true ]; then
            BUMP="minor"
          fi

          echo "bump=$BUMP" >> $GITHUB_OUTPUT
          echo "Determined bump type: $BUMP"

      - name: Calculate next version
        id: next
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          BUMP="${{ steps.analyze.outputs.bump }}"

          # Remove 'v' prefix for calculation
          VERSION=${CURRENT#v}

          # Split version into parts
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Default to 0 if not set
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Calculate next version
          case $BUMP in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT_VERSION"

      - name: Post version preview comment
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.version }}';
            const nextVersion = '${{ steps.next.outputs.version }}';
            const bumpType = '${{ steps.analyze.outputs.bump }}';

            const body = `## Version Preview

            | Current | Next | Bump Type |
            |---------|------|-----------|
            | \`${currentVersion}\` | \`${nextVersion}\` | **${bumpType}** |

            ### How version is determined:
            - \`feat!:\` or \`BREAKING\` in commit → **major** bump
            - \`feat:\` in commit → **minor** bump
            - All other commits → **patch** bump

            ---
            *This preview is based on conventional commit analysis. Actual release version may vary.*`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('Version Preview')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
